# warning: autogenerated code; don't bother to change this, change mktypeset.b or abc.b instead
Abc: module {
	PATH: con "/dis/alphabet/abc.dis";
	Value: adt {
		m:	fn(v: self ref Value): ref Value.Vm;	# vmods
		t:	fn(v: self ref Value): ref Value.Vt;	# vtypes
		A:	fn(v: self ref Value): ref Value.VA;	# abc
		w:	fn(v: self ref Value): ref Value.Vw;	# wfd
		c:	fn(v: self ref Value): ref Value.Vc;	# cmd
		r:	fn(v: self ref Value): ref Value.Vr;	# status
		f:	fn(v: self ref Value): ref Value.Vf;	# fd
		s:	fn(v: self ref Value): ref Value.Vs;	# string
		typec: fn(v: self ref Value): int;
		type2s:	fn(t: int): string;
		free: fn(v: self ref Value, used: int);
		dup:	fn(v: self ref Value): ref Value;
		pick {
		Vm =>
			i: Modulesval;
		Vt =>
			i: Typesval;
		VA =>
			i: Abcval;
		Vw =>
			i: chan of ref Sys->FD;
		Vc =>
			i: ref Sh->Cmd;
		Vr =>
			i: chan of string;
		Vf =>
			i: chan of ref Sys->FD;
		Vs =>
			i: string;
		}
	};
	init: fn();
	Abcval: adt {
		refcount: chan of int;
		alphabet: Alphabet;
	};
	Typesval: adt {
		abc: ref Value.VA;
		types: list of ref Type;
	};
	Modulesval: adt {
		abc: ref Value.VA;
		types: list of ref Type;
		mods: list of (string, string, ref Sh->Cmd);
		query: chan of (string, chan of (string, ref Sh->Cmd));
	};
	Type: adt {
		name: string;
		actname: string;
		nodup: int;
		destructor: ref Sh->Cmd;
	};
	mkabc: fn(alphabet: Alphabet): ref Value.VA;

};

Abcmodule: module {
	types: fn(): string;
	init: fn();
	quit: fn();
	run: fn(errorc: chan of string, r: ref Reports->Report,
		opts: list of (int, list of ref Abc->Value), args: list of ref Abc->Value): ref Abc->Value;
};

Declares: module {
	PATH: con "/dis/alphabet/abc/declares.dis";
	init: fn();
	quit: fn();
	declares: fn(a: Alphabet, decls: ref Sh->Cmd, errorc: chan of string, stopc: chan of int): string;
};
